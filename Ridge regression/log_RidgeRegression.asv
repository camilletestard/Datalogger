%% Log_RidgeRegression
% Run a ridge regression (code from Musall et. al)


%% Load data

%Set path
is_mac = 0;
if is_mac
    cd('~/Dropbox (Penn)/Datalogger/Deuteron_Data_Backup/Ready to analyze output/')
else
    cd('C:/Users/GENERAL/Dropbox (Penn)/Datalogger/Deuteron_Data_Backup/Ready to analyze output/')
end
filePath = uigetdir('', 'Please select the experiment directory'); % Enter the path for the location of your Deuteron sorted neural .nex files (one per channel)

if is_mac
    cd('~/Dropbox (Penn)/Datalogger/Results/')
else
    cd('C:/Users/GENERAL/Dropbox (Penn)/Datalogger/Results/')
end
savePath = uigetdir('', 'Please select the result directory');

clearvars -except savePath filePath is_mac

%Set temporal resolution, channel
temp = 1; temp_resolution = 1; chan = 1; channel_flag = "all";
%for temp_resolution = [1/30, 1/20,  1/10, 1/5, 1/2, 1, 2, 5, 10]
%1 for second resolution, 10 for 100msec resolution, 100 for 10msec resolution, 1000 for msec resolution. etc.
%0.1 for 10sec resolution, 1/5 for 5sec resolution

%Set channels: 'TEO', 'vlPFC' or 'all'
%for channel_flag = ["vlPFC", "TEO", "all"]

%Get data with specified temporal resolution and channels
[Spike_rasters, labels, labels_partner, behav_categ, block_times, monkey, reciprocal_set, social_set, ME_final]= log_GenerateDataToRes_function(filePath, temp_resolution, channel_flag, is_mac);
%filePath is the experimental data path
%Temp_resolution is the temporal resolution at which we would like to
%analyze the data
%Channel_flag specifies with channels to include: only TEO array, only
%vlPFC array or all channels
%is_mac is whether a mac or a pc is being used
disp('Data Loaded')

%Format data
Spike_count_raster = Spike_rasters';

%% Set options

%set up sampling rate (not sure this is useful, but it's used in code further down so i'll keep it for now).
opts.Fs = 1;

%Set up windows for time varying kernels. Multiplying factor is in seconds
%(recall FS is samples/second ),so can adjust window accordingly
opts.mPreTime = round(1 * opts.Fs); %motor pre time
opts.mPostTime = round(2 * opts.Fs); %motor post time

opts.folds = 10; %number of folds for cross-validation


%% Preprocessing, extract and format behavioral events

%Extract behavior info:
behavior_labels_subject = cell2mat({labels{:,3}}'); %Extract unique behavior info
behavior_labels_partner = cell2mat({labels_partner{:,3}}'); %Extract unique behavior info for partner
block_labels = cell2mat({labels{:,10}}'); %Extract block info

%Compute the %of timepoints with unidentified behavior
%Important note to keep in mind: I still think that the timepoints where
%there were no behaviors assigned should be excluded...
no_behavs_timepoints = length(find(behavior_labels_subject == 28))/length(behavior_labels_subject);
disp('%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%')
fprintf('Percent timepoints without a behavior assigned: %s \n', num2str(no_behavs_timepoints));
disp('%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%')

%Create subject behavior regressors:
subject_behav_reg = zeros(size(Spike_count_raster,1), length(behav_categ)-1); %initialize
for b = 1:length(behav_categ)-1
    idx = find(behavior_labels_subject == b);
    subject_behav_reg(idx,b) = 1;
end

%Create partner behavior regressors:
partner_behav_reg = zeros(size(Spike_count_raster,1), length(behav_categ)-1); %initialize
for b = 1:length(behav_categ)-1
    idx = find(behavior_labels_partner == b);
    partner_behav_reg(idx,b) = 1;
end

%Create block regressor:
block_reg = zeros(size(Spike_count_raster,1), length(unique(block_labels))); %initialize
for b = 1:length(unique(block_labels))
    idx = find(block_labels == b);
    block_reg(idx,b) = 1;
end

% %Create behavior change regressor (exclude for now because we do not seem
% to be able to detect behavior shifts irrespective of the shift)
% subject_behav_change_reg = zeros(size(Spike_count_raster,1), 1); %initialize
% subject_behav_change_reg(find(diff(behavior_labels_subject)~=0)+1) = 1;

%Combine behavioral events
Behavior_events=[subject_behav_reg, partner_behav_reg, block_reg];

disp('Preprocessing - adding events done')

%% Set up event types

%Get variable names
BehaviorEventNames = [behav_categ(1:end-1), append('partner.',behav_categ(1:end-1)),string(block_times{:,"Behavior"})'];

%Set up event type here.
allEventTypes=ones(size(BehaviorEventNames))*3;
% For now I will assign all behavioral events as event type 3
%Event Type 1 = Whole trial
%Event Type 2 = from stimulus onset to the rest of the trial
%Event Type 3 = from before movement onset to after movement onset (pre & post time)
allEventsInfo = [BehaviorEventNames; allEventTypes]';

disp('Preprocessing - Assigning event types done')

%% Preprocessing - Selecting Analog Tracking
%For now we don't need to do anything here...

moveR = ME_final;

%% Setup Design Matrix - Regressor labels

regLabels = BehaviorEventNames';
regLabels(length(allEventsInfo)+1) = {'Motion Energy L'};
regLabels(length(allEventsInfo)+2) = {'Motion Energy R'};


disp('Setup Design Matrix - Regressor labels done')

%% Preprocessing - Grouping regressors for later cross-validation
%For now only include behavior and motion energy

regGroups = {'BehavioralEvents' 'Movements'};
regGroups{2,1} = BehaviorEventNames';
regGroups{2,2} = {'Motion Energy L' 'Motion Energy R'} ;

disp('Preprocessing - Grouping regressors for later cross-validation done')

%% Setup Design Matrix - Behavioral Events


%Creates task regressors with the time varying kernels as described in Churchland
[behavR, behavIdx] = log_makeDesignMatrix(temptaskEvents, behavkEventType, opts);

%% Setup Design Matrix - Movement
% Create movement events from analog traces

[dMat, traceOut, moveIdx] = log_analogToDesign(std_movR, nanstd(std_movR)*2, opts, opts.Fs , opts.Fs , motorIdx, 0, taskEventName);
% dMat = "digitized" (or binarized) movement regressors. One cell per movement variable, per trial
% traceOut = original analog traces
% moveIdx = indices of regressors to keep track of what movement variable a regressor belongs to.

%moveR contains the movement events (movements above a certain
%threshold), the original movement variables and ME.
moveR = [cat(1,temp_moveR{:}), traceOut, video_var_hold]; %moveR structure: Time X num mvmt regressors

disp('Setup Design Matrix - Movements done')

%% Deal with Nans in the behavior data
%I.e. moments with undefined behaviors.
% Question: should i remove timepoints where both the partner and the
% subject have undefined behaviors? only one of the two?

all_nan_inds = [];
percent_lost_to_nans = size(all_nan_inds,1)/size(Spike_count_raster,1)

%remove from predictors and neural data
moveR(all_nan_inds,:) = []; %blank these indices out
behavR(all_nan_inds,:) = []; %blank these indices out
zero_regressors_move = find(all(moveR == 0,1));
zero_regressors_behav = find(all(behavR == 0,1));

%remove empty regressors
if ~isempty(zero_regressors_behav)
    taskR(:,zero_regressors_behav) = [];
    taskIdx(zero_regressors_behav) = []; %CT: Make sure you remove regIdx every time regressors are removed from fullR
end
if ~isempty(zero_regressors_move)
    moveR(:,zero_regressors_move) = [];
    moveIdx(zero_regressors_move) = [];
end

%Remove the nan time points in regressors from the neuronal data
Vc(all_nan_inds,:) = [];


disp('Nans removed')

%2020-12-19 CT: Remove regressors with less than 10 events (as in
%Musall et. al. 2019)
low_events_idx= find(sum(behavR,1)<10);
behavkR(:,low_events_idx)=[];
behavIdx(low_events_idx)=[];

 %% Combine Design Matrix
    
    %Combine Design Matrix
    fullR=[taskR, moveR];
    
    %Collect all indecies together.
    regIdx =[taskIdx; moveIdx'];
        
    disp('Design Matrix Setup Done')
    

 %% Center and Standardize Continuous Data
    %Center both analog (i.e. movement/tracking data) and neural data.
    
    
    % New approach: Find columns that don't just contain non-zero or one values:
    [~, columns]=find(fullR~=0 & fullR~=1);
    analoginds = unique(columns); clear columns
    
    %standarize analog regressors
    fullR(:,analoginds) = (fullR(:,analoginds)- mean(fullR(:,analoginds),1))./std(fullR(:,analoginds));
    
    
    %Churchland median centered the neuronal data, so we will do the same.
    Vc = (Vc - median(Vc,1));
    
    disp('Center and standardize continuous data Done')









%end
